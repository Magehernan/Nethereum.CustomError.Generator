using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nethereum.ABI.FunctionEncoding.Attributes;
using Nethereum.Util;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Nethereum.CustomError.Generator;

[Generator]
internal class ErrorSourceGenerator : IIncrementalGenerator {
	private static readonly string attributeName = typeof(ErrorAttribute).FullName;
	private static readonly Sha3Keccack sha3Keccack = new();

	public void Initialize(IncrementalGeneratorInitializationContext context) {
		//if (!System.Diagnostics.Debugger.IsAttached) { System.Diagnostics.Debugger.Launch(); }

		IncrementalValuesProvider<GeneratorAttributeSyntaxContext> provider = context.SyntaxProvider.ForAttributeWithMetadataName(
				attributeName,
				predicate: static (node, _) => node is ClassDeclarationSyntax,
				transform: static (ctx, _) => ctx
			);

		IncrementalValueProvider<(Compilation Left, ImmutableArray<GeneratorAttributeSyntaxContext> Right)> compilation = context.CompilationProvider.Combine(provider.Collect());

		context.RegisterSourceOutput(compilation, (context, val) => Execute(context, val.Left, val.Right));
	}

	private void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<GeneratorAttributeSyntaxContext> list) {
		//if (!System.Diagnostics.Debugger.IsAttached) { System.Diagnostics.Debugger.Launch(); }

		Dictionary<string, INamedTypeSymbol> errorClasses = [];
		IOrderedEnumerable<GeneratorAttributeSyntaxContext> ordered = list.OrderBy(t => compilation.GetSemanticModel(t.TargetNode.SyntaxTree).GetDeclaredSymbol(t.TargetNode)!.ContainingNamespace.ToDisplayString());
		foreach (GeneratorAttributeSyntaxContext syntax in ordered) {
			if (compilation.GetSemanticModel(syntax.TargetNode.SyntaxTree).GetDeclaredSymbol(syntax.TargetNode) is not INamedTypeSymbol symbol) {
				continue;
			}
			string errorName = syntax.Attributes[0].ConstructorArguments[0].Value!.ToString();
			string signatureSha = GenerateSignature(errorName, symbol.GetMembers().Where(x => x.GetAttributes().Length > 0).ToImmutableArray());
			if (errorClasses.ContainsKey(signatureSha)) {
				continue;
			}
			errorClasses.Add(signatureSha, symbol);
		}

		List<string> errorMapper = [];
		List<string> errorFunction = [];
		foreach (KeyValuePair<string, INamedTypeSymbol> symbol in errorClasses) {
			string className = symbol.Value.ToDisplayString();
			errorMapper.Add($""" 
							"{symbol.Key}" => GenerateMessage(exception.DecodeError<{className}>()),
				""");
			errorFunction.Add($$""" 
					protected abstract string GenerateMessage({{className}} error);
				""");
		}

		string code = $$"""
			// <auto-generated/>
			namespace Nethereum.CustomError;
						
			public abstract class CustomErrorMapperBase {
				protected abstract string CustomErrorNotFound();

				protected string FindMessage(Nethereum.Contracts.SmartContractCustomErrorRevertException exception) {
					return exception.ExceptionEncodedData[..10] switch {
			{{string.Join("\n", errorMapper)}}

						_ => CustomErrorNotFound(),
					};
				}
				
			{{string.Join("\n", errorFunction)}}
			}
			""";

		context.AddSource("CustomErrorMapperBase.g.cs", code);
	}

	private string GenerateSignature(string name, ImmutableArray<ISymbol> parameters) {
		StringBuilder signature = new();
		signature.Append(name);
		signature.Append(GenerateParametersSignature(parameters));
		return $"0x{sha3Keccack.CalculateHash(signature.ToString()).Substring(0, 8)}";
	}

	private string GenerateParametersSignature(ImmutableArray<ISymbol> parameters) {
		StringBuilder signature = new();
		signature.Append("(");
		string[] parameterTypes = new string[parameters.Length];
		foreach (ISymbol member in parameters) {
			ImmutableArray<AttributeData> attributeDatas = member.GetAttributes();
			if (attributeDatas.Length == 0) {
				continue;
			}
			string? type = attributeDatas[0].ConstructorArguments[0].Value?.ToString();
			int? order = attributeDatas[0].ConstructorArguments[2].Value as int?;
			if (type is null || order is null) {
				continue;
			}
			parameterTypes[order.Value - 1] = type;
		}

		string paramNames = string.Join(",", parameterTypes);
		signature.Append(paramNames);
		signature.Append(")");
		return signature.ToString();
	}
}
